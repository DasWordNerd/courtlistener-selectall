"""
This tool allows you to partially clone data from courtlistener.com to your
local environment, you only need to pass the type and object id and run it.

manage.py clone_from_cl --type Opinion --id 9355884
manage.py clone_from_cl --type Docket --id 5377675
manage.py clone_from_cl --type Person --id 16207
manage.py clone_from_cl --type Court --id usnmcmilrev

This tool is only for development purposes, so it only works when 
the DEVELOPMENT env is set to True. It also relies on the CL_API_TOKEN
env variable.

This is still work in progress, some data is not cloned yet.
"""

import os
import sys

import environ
import requests
from django.db import transaction
from django.utils.dateparse import parse_date

from cl.lib.command_utils import VerboseCommand
from cl.people_db.models import Person
from cl.search.models import Citation, Court, Docket, Opinion, OpinionCluster
from cl.search.tasks import add_items_to_solr

env = environ.FileAwareEnv()
DEVELOPMENT = env.bool("DEVELOPMENT", default=False)

VALID_TYPES = ("Opinion", "Docket", "Person", "Court")

cluster_endpoint = "https://www.courtlistener.com/api/rest/v3/clusters/"
people_endpoint = "https://www.courtlistener.com/api/rest/v3/people/"
courts_endpoint = "https://www.courtlistener.com/api/rest/v3/courts/"


class Command(VerboseCommand):
    help = (
        "A helper function clone a data from courtlistener.com into local "
        "environment "
    )

    def __init__(self, *args, **kwargs):
        super(Command, self).__init__(*args, **kwargs)
        self.verbosity = None
        self.options = []
        self.type = None

    def add_arguments(self, parser):
        parser.add_argument(
            "--type",
            type=str,
            choices=VALID_TYPES,
            help="Object type to clone. Current choices are %s"
            % ", ".join(VALID_TYPES),
        )

        parser.add_argument(
            "--id",
            help="Object id, " "object id to clone",
        )

    def handle(self, *args, **options):
        super(Command, self).handle(*args, **options)
        self.verbosity = int(options.get("verbosity", 1))
        self.type = options.get("type")
        self.id = options.get("id")

        if not self.id:
            self.stdout.write("Object id required!")
            sys.exit(1)

        if DEVELOPMENT:
            if self.type == "Opinion":
                self.clone_opinion()
            elif self.type == "Docket":
                self.clone_docket()
            elif self.type == "Person":
                self.clone_person()
            elif self.type == "Court":
                self.clone_court()
            else:
                self.stdout.write("Invalid type!")

        else:
            self.stdout.write("Command not enabled for production environment")

    def clone_opinion(self) -> None:
        """Download opinion cluster data from courtlistener.com and add it to
        local environment
        """

        try:
            obj = OpinionCluster.objects.get(pk=self.id)
            print(f"OpinionCluster with id: {self.id} already in local env.")
            return
        except OpinionCluster.DoesNotExist:

            s = requests.session()
            s.headers = {
                "Authorization": f"Token {os.environ.get('CL_API_TOKEN', '')}"
            }
            cluster_endpoint = f"https://www.courtlistener.com/api/rest/v3/clusters/{self.id}/"
            results = s.get(cluster_endpoint).json()

            cluster_datum = results
            docket_datum = s.get(cluster_datum["docket"]).json()
            court_datum = s.get(docket_datum["court"]).json()
            citation_data = cluster_datum["citations"]
            opinion_data = cluster_datum["sub_opinions"]
            # delete resource_uri value generated by DRF
            del court_datum["resource_uri"]
            del docket_datum["resource_uri"]
            del cluster_datum["resource_uri"]
            # delete fields with fk or m2m relations or unneeded fields
            del docket_datum["clusters"]
            del docket_datum["original_court_info"]
            del docket_datum["absolute_url"]
            del docket_datum["audio_files"]
            del docket_datum["tags"]
            del docket_datum["panel"]
            del cluster_datum["docket"]
            del cluster_datum["citations"]
            del cluster_datum["sub_opinions"]
            del cluster_datum["absolute_url"]
            del cluster_datum["panel"]
            del cluster_datum["non_participating_judges"]
            with transaction.atomic():
                # Get or create required court
                try:
                    ct = Court.objects.get_or_create(**court_datum)
                except:
                    ct = Court.objects.filter(pk=court_datum["id"])
                docket_datum["court"] = ct[0]

                # Create docket
                Docket.objects.create(**docket_datum)

                for cite_data in citation_data:
                    cite_data["cluster_id"] = cluster_datum["id"]
                cluster_datum["docket_id"] = docket_datum["id"]

                # Create opinion cluster
                OpinionCluster.objects.create(**cluster_datum)

                for cite_data in citation_data:
                    # Create citations
                    cite_data["cluster_id"] = cluster_datum["id"]
                    Citation.objects.create(**cite_data)

                for op in opinion_data:
                    op_data = s.get(op).json()
                    # delete fields with fk or m2m relations or unneeded fields
                    del op_data["opinions_cited"]
                    del op_data["cluster"]
                    del op_data["absolute_url"]
                    del op_data["resource_uri"]
                    del op_data["author"]
                    del op_data["joined_by"]
                    op_data["cluster_id"] = cluster_datum["id"]

                    # Create opinion
                    op = Opinion.objects.create(**op_data)

                    # Add opinion to search engine
                    add_items_to_solr.delay([op.id], "search.Opinion")

                print(
                    f"http://localhost:8000/opinion/{cluster_datum['id']}/{docket_datum['slug']}/"
                )

    def clone_docket(self) -> None:
        """Download docket data from courtlistener.com and add it to local
        environment
        """
        try:
            obj = Docket.objects.get(pk=self.id)
            print(f"Docket with id: {self.id} already in local env.")
            return
        except Docket.DoesNotExist:
            # Create new Docket

            s = requests.session()
            s.headers = {
                "Authorization": f"Token {os.environ.get('CL_API_TOKEN', '')}"
            }
            docket_endpoint = (
                f"https://www.courtlistener.com/api/rest/v3/dockets/{self.id}/"
            )
            docket_data = s.get(docket_endpoint).json()

            # Remove unneeded fields
            del docket_data["resource_uri"]
            del docket_data["original_court_info"]
            del docket_data["absolute_url"]
            # TODO helpers to create other objects and set m2m relations
            del docket_data["clusters"]
            del docket_data["audio_files"]
            del docket_data["tags"]
            del docket_data["panel"]

            with transaction.atomic():
                docket_data["court"] = self.get_court_from_url(
                    docket_data["court"]
                )
                docket_data["appeal_from"] = self.get_court_from_url(
                    docket_data["appeal_from"]
                )
                docket_data["assigned_to"] = self.get_person_from_url(
                    docket_data["assigned_to"]
                )
                Docket.objects.create(**docket_data)
                print(
                    f"http://localhost:8000/docket/{docket_data['id']}/{docket_data['slug']}/"
                )

    def clone_person(self):
        """Download person data from courtlistener.com and add it to local
        environment
        """
        person_url = f"{people_endpoint}{self.id}/"
        try:
            obj = Person.objects.get(pk=self.id)
            print(f"Person with id: {self.id} already in local env.")
            return
        except Person.DoesNotExist:
            person = self.get_person_from_url(person_url)
            print(f"http://localhost:8000/api/rest/v3/people/{self.id}/")

    def clone_court(self):
        """Download court data from courtlistener.com and add it to local
        environment
        """
        court_url = f"{courts_endpoint}{self.id}/"
        try:
            obj = Court.objects.get(pk=self.id)
            print(f"Court with id: {self.id} already in local env.")
            return
        except Court.DoesNotExist:
            person = self.get_court_from_url(court_url)
            print(f"http://localhost:8000/api/rest/v3/courts/{self.id}/")

    @staticmethod
    def get_court_from_url(court_url: str) -> Court | None:
        """Get court data from courtlistener api url"""
        if not court_url:
            return None
        s = requests.session()
        s.headers = {
            "Authorization": f"Token {os.environ.get('CL_API_TOKEN', '')}"
        }
        court_data = s.get(court_url).json()
        # delete resource_uri value generated by DRF
        del court_data["resource_uri"]

        try:
            ct = Court.objects.get_or_create(**court_data)
        except:
            ct = Court.objects.filter(pk=court_data["id"])[0]

        return ct

    @staticmethod
    def get_person_from_url(person_url: str) -> Person | None:
        """Get person data from courtlistener api url"""
        if not person_url:
            return None
        s = requests.session()
        s.headers = {
            "Authorization": f"Token {os.environ.get('CL_API_TOKEN', '')}"
        }
        person_data = s.get(person_url).json()
        # delete resource_uri value generated by DRF
        del person_data["resource_uri"]
        # delete fields with fk or m2m relations or unneeded fields
        # TODO create helpers to build that objects
        del person_data["aba_ratings"]
        del person_data["race"]
        del person_data["sources"]
        del person_data["educations"]
        del person_data["positions"]
        del person_data["political_affiliations"]
        # Prepare some values
        if person_data["date_dob"]:
            person_data["date_dob"] = parse_date(person_data["date_dob"])
        try:
            person, created = Person.objects.get_or_create(**person_data)
        except:
            person = Person.objects.filter(pk=person_data["id"])[0]

        return person
